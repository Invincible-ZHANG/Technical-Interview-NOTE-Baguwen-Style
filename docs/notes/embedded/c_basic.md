---
layout: note
title: "C语言基础"
date: 2025-07-17
excerpt: "嵌入式开发常用的C语言基础知识梳理，包括关键字用法、内存管理、编译原理等，助力面试与实际项目开发。"
categories: embedded
tags:
  - C语言
  - 嵌入式
  - 基础知识
creat_date: 2025-07-11
---

# C语言/C++ 基础知识

## 1.面试常问关键字
*Tips：去背诵概念完全没有任何的意义，需要你能结合一些例子去记忆。*

### 1.1 `volatile` 关键字

- **作用**：告诉编译器该变量可能会被外部因素改变，禁止优化。
即告诉编译器每次存取该变量的时候都要从内存去存取而不是使用它之前在寄存器中的备份。

> 什么是编译器优化?

>我们首先去理解CPU 的工作原理。CPU在执行程序的时候会将指令从内存中取出来，然后放到寄存器中执行。
寄存器是CPU内部的高速缓存，速度非常快。
编译器优化就是为了提高程序的执行效率，减少不必要的内存访问和计算。
>

例如，如果一个变量在程序中没有被修改，编译器可以将它的值缓存到寄存器中，而不是每次都从内存中读取。
所以我们就需要来讲一下内存读取规则。


```cpp
int a, b;// 为a,b申请内存
a = 1;  // 1 -> CPU 
		// CPU -> 内存（&a）
b = a;  // 内存（&a） -> CPU
		// CPU -> 内存（&b）
```

 - 如代码所示，a = 1这个程序，先将1写入CPU，再从CPU中将1写入a所在的内存地址中；
  - b = a是先从内存中将a的值取出到CPU，再从CPU将值存入b的内存地址中。

```cpp
int a = 1 , b, c; // 为a,b,c申请内存并初始化
b = a;            // 内存（&a） -> CPU
                  // CPU -> 内存（&b）
c = a;            // * 内存（&a） -> CPU *
                  // CPU -> 内存（&c）
```


如上图代码所⽰，上边的程序如果按第⼀段代码所说的顺序执⾏，则c = a语句在编译时
是可以被编译器优化的，即注释部分（* 内存（&a） -> CPU *）的内容不被执⾏，因为在b
= a这个语句中，a已经被移⼊过寄存器（CPU），那么在执⾏c = a时，就直接将a在寄存器
（CPU）中传递给c。这样就减少了⼀次指令的执⾏，就完成了优化。

上⾯就是编译器优化的原理过程，但是这个过程，有时会出现问题，⽽这个问题也就
**volatile**存在的意义！


 **volatile的引⼊**

>上边程序中，如果在执⾏完b = a后，a此时的值存放在CPU中。但是a在内存中⼜发⽣
>了变化（⽐如中断改变了a的值），但是存在CPU中的a是原来未变的a，按理应该是已经变
>化后的a赋值给c，但是此时却导致未变化的a赋值给了c。


这种问题，就是编译器⾃⾝优化⽽导致的。为了防⽌编译器优化变量a，引⼊了volatile
关键字，使⽤该关键字后，程序在执⾏时c = a时，就会先去a的地址读出a到CPU，再从
CPU将a的值赋予给c。这样就防⽌了被优化。

~~~
volatile int a = 1;  // 只有 a 是 volatile
int b, c;            // b、c 普通变量

b = a;               // 每次都从内存(&a)读
c = a;               // 每次都从内存(&a)读
~~~



**哪些情况下使⽤volatile**

（1）**并⾏设备的硬件寄存器**。存储器映射的硬件寄存器通常加volatile，因为寄存器随
时可以被外设硬件修改。当声明指向设备寄存器的指针时⼀定要⽤volatile，它会告诉编译
器不要对存储在这个地址的数据进⾏假设。

（2） ⼀个中断服务程序中修改的供其他程序检测的变量。volatile提醒编译器，它后⾯
所定义的变量随时都有可能改变。因此编译后的程序每次需要存储或读取这个变量的时候，
都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存
储，可能暂时使⽤寄存器中的值，如果这个变量由别的程序更新了的话，将出现不⼀致的现
象。

（3）多线程应⽤中被⼏个任务共享的变量。    

---
### 1.1.2 static关键字

static关键词的作⽤？

static是被声明为静态类型的变量，存储在静态区（全局区）中，其**⽣命周期为整个程
序**，如果是静态局部变量，其作⽤域为⼀对 {.. } 内，如果是静态全局变量，其作⽤域为当前
⽂件。静态变量如果没有被初始化，则⾃动初始化为0。


为什么 static变量只初始化⼀次？

**对于所有的对象（不仅仅是静态对象），初始化都只有⼀次**，⽽由于静态变量具有“记
忆”功能，初始化后，⼀直都没有被销毁，都会保存在内存区域中，所以不会再次初始化。
存放在静态区的变量的⽣命周期⼀般⽐较⻓，它与整个程序“同⽣死、共存亡”，所以它只
需初始化⼀次。⽽auto变量，即⾃动变量，由于它存放在栈区，⼀旦函数调⽤结束，就会
⽴刻被销毁。

**static修饰的全局变量，只能在本⽂件被调⽤；修饰的函数也只能在本⽂件调⽤。**

>补充：auto变量
> - 作用域：只在声明它的代码块（通常是函数体或语句块）内可见。
> - 存储期：当程序执行到它所在的作用域时，自动分配存储空间；当离开该作用域时，自动回收空间。
> - 存储位置：一般分配在栈（stack）上。
> -  关键字可省略：在 C/C++ 中，局部变量默认就是自动变量，所以写不写 auto 关键字都一样：


```
void foo() {
    auto int x = 42;  // 显式用 auto
    int y = 13;       // 隐式也是 auto
    // x 和 y 都是自动变量
}
```


### 1.3 const关键字

（a）定义变量（局部变量或全局变量）为常量，例如：
~~~
const int a = 100; //定义一个常数
a = 50; //error,常量的值不能被修改
const int b; // error,常量在被定义的时候必须初始化
~~~

（b）修饰指针

~~~
//第一种
const int *p1;  //常量指针，p本身不是const的，但是p指向的变量是const的

//第二种
int const *p2;   //同第一种，const在*前

//第三种
int* const p3;   //指针常量，p本身是一个const，但是p指向变量不是const

//第四种
const int* const p4； //p本身是一个const，而且p指向的变量是const。
~~~

第⼀种和第⼆种是常量指针；第三种是指针常量；第四种是指向常量的常指针。

（b1）⾯试问题1：什么是常量指针？
 - 常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的⽅式
来改变变量的值的。
 - 常量指针指向的值不能改变，但是这并不是意味着指针本⾝不能改变，常量指针
可以指向其他的地址。

~~~
const int *p；
int a = 12；

p = &a;
*p = 15;

printf（" p = %d \r\n " ,a）;
return 0;
~~~

p1是定义的常量指针，p1指向a的地址，*p1 = 15是不⾏的，因为不能通过常
量指针去改变变量的值，如果去掉const则是可以的。


没有const时，利⽤*p1可以去对a的值进⾏修改，如下面代码：

~~~
int *p；
int a = 12；

p = &a;
*p = 15;

printf（" p = %d \r\n " ,a）;
return 0;
~~~

