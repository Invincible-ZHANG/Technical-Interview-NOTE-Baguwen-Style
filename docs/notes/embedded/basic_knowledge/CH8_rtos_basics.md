---
layout: default
title: "RTOS 基础"
date: 2025-07-07
excerpt: "入门实时操作系统（RTOS）的核心概念、调度模式与典型应用，为后续深入嵌入式系统开发和项目实践打下基础。"
categories: embedded
tags:
  - RTOS
  - 嵌入式
  - 实时操作系统
---

# RTOS 基础

本文介绍实时操作系统（RTOS, Real-Time Operating System）的基本概念与典型任务调度模式。内容涵盖 RTOS 的作用、常见架构、任务优先级与时间管理机制，帮助你建立对嵌入式实时系统的完整认知，并为实际工程开发和面试打好理论基础。

---


<!--
> 基于Freertos的RTOS，来写的本篇文章

## 1. RTOS 的作用

在裸机系统中，所有的程序基本都是自己写的，所有的操作都是在一个无限的大循环 里面实现。
现实生活中的很多中小型的电子产品用的都是裸机系统，而且也能够满足需求。 
但是为什么还要学习 RTOS 编程，偏偏还要整个操作系统进来？

随着产品 要实现的功能越来越多，单纯的裸机系统已经不能够完美地解决问题，反而会使编程变得 更加复杂，如果想降低编程的难度，我们可以考虑引入 RTOS 实现多任务管理，这是使用 RTOS 的最大优势。

一般学习的第一步都是用API来实现多任务管理，RTOS的API是一个抽象的概念，实际上RTOS的API是对底层硬件的封装。

为了方便调试，还是需要去了解 RTOS 的底层原理。

FreeRTOS 版权

* FreeRTOS 由美国的 Richard Barry 于 2003 年发布，Richard Barry 是 FreeRTOS 的拥有 者和维护者，在过去的十多年中 FreeRTOS 历经了 9 个版本，与众多半导体厂商合作密切， 累计开发者数百万，是目前市场占有率最高的 RTOS。
* FreeRTOS 于 2018 年被亚马逊收购，改名为 AWS FreeRTOS，版本号升级为 V10，且 开源协议也由原来的 GPLv2+修改为 MIT，与 GPLv2+相比，MIT 更加开放，你完全可以理 解为是为所欲为的免费。V9 以前的版本还是维持原样，V10 版本相比于 V9 就是加入了一 些物联网相关的组件，内核基本不变。亚马逊收购 FreeRTOS 也是为了进军眼下炒的火热 的物联网和人工智能。



FreeRTOS 是一款 “开源免费”的实时操作系统，遵循的是 GPLv2+的许可协议。这里说 到的开源，指的是你可以免费得获取到 FreeRTOS 的源代码，且当你的产品使用了 FreeRTOS 且没有修改 FreeRTOS 内核源码的时候，你的产品的全部代码都可以闭源，不用开源，但是当 你修改了 FreeRTOS 内核源码的时候，就必须将修改的这部分开源，反馈给社区，其它应用部 分不用开源。免费的意思是无论你是个人还是公司，都可以免费地使用，不需要掏一分钱。


## 2. RTOS 的移植

FreeRTOS 包含 Demo 例程和内核源码（比较重要，我们就需要提取该目录下的大部分 文件）。
FreeRTOS 文件夹下的 Source 文件夹里面包含的是 FreeRTOS 内 核的源代码，
我们移植 FreeRTOS 的时候就需要这部分源代码；FreeRTOS 文件夹下的 Demo 文件夹里面包含了 FreeRTOS 官方为各个单片机移植好的工程代码，FreeRTOS 为了 推广自己，会给各种半导体厂商的评估板写好完整的工程程序，这些程序就放在 Demo 这 个目录下，这部分 Demo 非常有参考价值。


**往裸机工程添加 FreeRTOS 源码**

首先在裸机工程模板根目录下新建一个文件夹，命名为“FreeRTOS”，并且在 FreeRTOS 文件夹下新建两个空文件夹，
分别命名为“src” 与“port”，src 文件夹用于保存 FreeRTOS 中的核心源文件，也就是我们常说的 ‘.c 文件’，
**port 文件夹用于保存内存管理以及处理器架构相关代码**，这些代码 FreeRTOS 官方已经提供给我们的，直接使用即可，在前面已经说了，FreeRTOS 是软件，我们的开发版是硬件，软硬件必须有桥梁来连接，这些与处理器架构相 关的代码，可以称之为 RTOS 硬件接口层，它们位于 FreeRTOS/Source/Portable 文 件夹下。
“include”文件夹，它是我们需要用到 FreeRTOS 的一些头文件，将它直接拷贝。

![Rtos01](images/rtos01.png)

-->

## 8.1
内存管理


| 文件名        | 优点                  | 缺点            | 说明                                                                                   |
| ---------- | ------------------- | ------------- | ------------------------------------------------------------------------------------ |
| `heap_1.c` | 分配简单，时间确定           | 只分配，不回收       | **最基础**的策略。只支持线性分配，比如像栈一样一直向后分配，**没有释放机制**。优点是**极快且稳定**，适合初始化阶段或一次性分配内存的场景（如游戏关卡加载）。 |
| `heap_2.c` | 动态分配，最佳匹配           | 有碎片，时间不定      | 引入了**空闲块管理机制**，会尝试“最优匹配”（如 best-fit），更智能，但缺点是**可能产生碎片**，比如有很多小块被占用却无法合并，且查找耗时不确定。    |
| `heap_3.c` | 调用标准库函数（如 `malloc`） | 速度慢，时间不定      | 直接使用 `malloc/free` 等系统库函数，优点是**通用性强**，缺点是**系统开销大、不适用于硬实时系统**。适合通用 C 程序或操作系统级分配。      |
| `heap_4.c` | 相邻空闲内存可合并           | 可解决碎片问题，但时间不定 | 在 `heap_2` 的基础上新增了**空闲块合并功能**（coalescing），可以合并相邻的空闲块来减少碎片，但合并过程需要遍历，仍然**耗时不确定**。     |
| `heap_5.c` | 支持分隔的内存块（多区域）       | 可解决碎片问题，但时间不定 | 在 `heap_4` 上扩展，支持**多内存区域/分区分配（如小对象池、大块池）**。适合复杂系统如 RTOS，效率和内存利用率进一步提高。               |


> 这些 heap_*.c 文件是实现不同策略的堆内存管理器，类似于我们平时使用的 malloc/free，但它们更接近底层，可以用于嵌入式或自定义内存池等场景。


### 8.1.1 关于heap_1.c

heap_1.c 是 FreeRTOS 提供的最简单的内存管理器实现。它只支持线性分配内存，不能释放已分配的内存块。适用于那些只需要一次性分配内存的场景，比如游戏关卡加载等。由于没有释放机制，它的内存使用效率较低，但速度非常快且稳定。

它只实现了 pvPortMalloc，没有实现 vPortFree。 如果你的程序不需要删除内核对象，那么可以使用 heap_1。FreeRTOS 在创建任务时，需要 2 个内核对象：task controlblock(TCB)、stack。（TCB任务控制块和栈）。