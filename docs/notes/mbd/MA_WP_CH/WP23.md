## 删除/解耦interactive求解器


1. RBDscene.cpp

```
#include "./RBDColliderGroup.h"
#include "./RBDClusterLagrangeMultipliers.h"
// #include "./RBDClusterLagrangeMultipliersInteractive.h"
#include "./RBDClusterImpulseBased.h"
#include "./RBDClusterPenalty.h"
#include "../RBDClusterSequentialImpulse.h"


...

RBDCluster* RBDScene::createNewCluster()
{
   const CONSTRAINTSOLVERTYPE t = this->constraintSolverType();
   if (t == CST_IMPULSEBASED)
   {
      return new RBDClusterImpulseBased(this);
   }
   else if (t == CST_PENALTY)
   {
      return new RBDClusterPenalty(this);
   }
  /* else if (
      t == CST_LAGRANGEINTERACTIVEDANTZIG
      || t == CST_LAGRANGEINTERACTIVEGS
      || t == CST_LAGRANGEINTERACTIVEAUTO)
   {
      return new RBDClusterLagrangeMultipliersInteractive(this);
   }*/
   //(ci) use the attached LagrangeDebugObserver
   else if (myLDOPtr)
   {
      return new RBDClusterLagrangeMultipliers(this, myLDOPtr);
   }
}
```

2. RBDClusterLagrangeMultipliersInteractive.h"

```
{
    {
//	VSM::VectorN* lagrangeMultipliers; 

	RBDConstraintResourcePtrSet myConstraintResources; 

	VSLibRBDynMath::RBMMixedLCP* myLcp;

};

//#include "RBDClusterLagrangeMultipliersInteractive.hpp"  //删除
 
}

#endif
```

3. RBDscene.h

```
   enum CONSTRAINTSOLVERTYPE
   {
      CST_LAGRANGEDANTZIG, 
      CST_LAGRANGEGS, 
      CST_LAGRANGEAUTO, 
      /*CST_LAGRANGEINTERACTIVEDANTZIG, 
      CST_LAGRANGEINTERACTIVEGS, 
      CST_LAGRANGEINTERACTIVEAUTO, */  删除
      CST_LAGRANGEDANTZIGEXP, 
      CST_IMPULSEBASED, 
      CST_PENALTY,
      CST_SEQUENTIALIMPULSE
   }; 
```


4. VSPluginRBDynamXMainSimStateExtension.cpp
```
   if (solverName.toLower() == "dantziginternal")
   {
      myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEDANTZIGEXP);
   }
   // 删除注释掉的代码
   //else if (solverName.toLower() == "lagrangeinteractivedantzig")
   //{
   //   myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEINTERACTIVEDANTZIG);
   //}
   //else if (solverName.toLower() == "lagrangeinteractivegs")
   //{
   //   myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEINTERACTIVEGS);
   //}
   //else if (solverName.toLower() == "lagrangeinteractiveauto")
   //{
   //   myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEINTERACTIVEAUTO);
   //}
   else if (solverName.toLower() == "lagrangedantzig")
   {
      myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEDANTZIG);
   }
```


5. VSPluginRBDynamXOptions.cpp
```
 constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangeauto", tr("Lagrange Multipliers, Auto"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangedantzig", tr("Lagrange Multipliers, Dantzig"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangegs", tr("Lagrange Multipliers, Projected Gauss-Seidel"))); 
   /*constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangeinteractivedantzig", tr("Lagrange Multipliers, Interaktiv, Dantzig"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangeinteractivegs", tr("Lagrange Multipliers, Interaktiv, Gauss-Seidel"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangeinteractiveauto", tr("Lagrange Multipliers, Interaktiv, Auto"))); */
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("dantziginternal", tr("Lagrange Multipliers, Dantzig (Experimental)"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("impulsebased", tr("Impulsbasiert, Iterativ"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("penalty", tr("Penalty"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("sequentialimpulse", tr("Sequential Impulse, Projected Gauss-Seidel")));

```


最后要删除pro文件清除Cmake


## 删除/解耦dantzig experimental求解器

1. RBDInverseDynamicsSolverLCP.cpp
```
#include "./RBDLcpGS.h"
#include "./RBDLcpDantzig.h"
//#include "./RBDLcpDantzigInternal.h"
#include "./RBDLcpSor.h"


VSM::VectorN VSLibRBDynamX::RBDInverseDynamicsSolverLCP::solve()
{
   switch (getRBDScene()->constraintSolverType())
   {
   case(RBDScene::CST_LAGRANGEDANTZIG) :
   {
      myLCP = new RBDLcpDantzig(getDimension(), getNumberEqualityConstraints());
      break;
   }
   /*case(RBDScene::CST_LAGRANGEDANTZIGEXP) :
   {
      myLCP = new RBDLcpDantzigExperimental(getDimension(), getNumberEqualityConstraints(), getRBDScene()->numberIterations());
      break;
   }*/
   case (RBDScene::CST_LAGRANGEGS) :
   {
      myLCP = new RBDLcpGS(getDimension(), getNumberEqualityConstraints(), getRBDScene()->numberIterations());
      break;
   }
   default:
   {
      if (getNumberEqualityConstraints() <= 0)
         myLCP = new RBDLcpGS(getDimension(), getNumberEqualityConstraints(), getRBDScene()->numberIterations());
      else
         myLCP = new RBDLcpDantzig(getDimension(), getNumberEqualityConstraints());
   }
   }
}
```


2. RBDClusterLagrangeMultipliers.cpp
```
#include "./RBDLcpGS.h"
#include "./RBDLcpDantzig.h"
//#include "./RBDLcpDantzigInternal.h"

switch (myScene->constraintSolverType())
      {
      case(RBDScene::CST_LAGRANGEDANTZIG):
      {
         myLcp = new RBDLcpDantzig(matA.rows(), numberEqualityConstraints);
         break;
      }
      /*case(RBDScene::CST_LAGRANGEDANTZIGEXP):
      {
         myLcp = new RBDLcpDantzigExperimental(matA.rows(), numberEqualityConstraints, myScene->numberIterations());
         break;
      }*/
      case (RBDScene::CST_LAGRANGEGS):
      {
         myLcp = new RBDLcpGS(matA.rows(), numberEqualityConstraints, myScene->numberIterations());
         break;
      }
      }

```


3. RBDscene.h

```
   enum CONSTRAINTSOLVERTYPE
   {
      CST_LAGRANGEDANTZIG, 
      CST_LAGRANGEGS, 
      CST_LAGRANGEAUTO, 
      // CST_LAGRANGEDANTZIGEXP, 
      CST_IMPULSEBASED, 
      CST_PENALTY,
      CST_SEQUENTIALIMPULSE
   }; 
```


4. VSPluginRBDynamXMainSimStateExtension.cpp
```
   /* if (solverName.toLower() == "dantziginternal")
   {
      myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEDANTZIGEXP);
   }

   */
   if (solverName.toLower() == "lagrangedantzig")
   {
      myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEDANTZIG);
   }
```



5. VSPluginRBDynamXOptions.cpp
```
 constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangeauto", tr("Lagrange Multipliers, Auto"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangedantzig", tr("Lagrange Multipliers, Dantzig"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("lagrangegs", tr("Lagrange Multipliers, Projected Gauss-Seidel"))); 
   
   /* constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("dantziginternal", tr("Lagrange Multipliers, Dantzig (Experimental)"))); 
   */
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("impulsebased", tr("Impulsbasiert, Iterativ"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("penalty", tr("Penalty"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("sequentialimpulse", tr("Sequential Impulse, Projected Gauss-Seidel")));

```



最后要删除pro文件清除Cmake
