## 修改求解器顺序的问题

1. VSPluginRBDynamXMainSimStateExtension.cpp

   ```cpp
   // 删除auto 及删除lagrange前缀
      QString solverName = mySettings.ReadString("constraintSolver", "dantzigauto");// <- change
      if (solverName.toLower() == "dantzigauto")// <- change
      {
         myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_DANTZIG);
      }
      else if (solverName.toLower() == "gs")
      {
         myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_GS);
      }
      /*删除
      else if (solverName.toLower() == "lagrangeauto")
      {
         myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_LAGRANGEAUTO);
      }
      */
      else if (solverName.toLower() == "penalty")
      {
         myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_PENALTY);
      }
      else if (solverName.toLower() == "sequentialimpulse") {
         myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_SEQUENTIALIMPULSE);
      }
      else
      {
         myRBDScene->setConstraintSolverType(VSLibRBDynamX::RBDScene::CST_DANTZIG);// <- change
      }
   ```
2. VSPluginRBDynamXOptions.cpp

```cpp
// 修改顺序和一些名字
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("dantzigauto", tr("Dantzig(auto)"))); 
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("sequentialimpulse", tr("Sequential Impulse Projected Gauss-Seidel")));
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("gs", tr("Projected Gauss-Seidel")));  
   constraintSolverValues.append(VSLibGUI::SettingsWrapper::ComboBox::Pair("penalty", tr("Penalty"))); 
```

3. RBDScene.cpp

   ```cpp
   RBDScene::RBDScene()
   : SceneElement()
   , myGravity(0, 0, double(-9.8065))
   , myConstraintSolverType(CST_DANTZIG)// <- change
   , myNumberIterations(100)
   , myGlobalCfm(double(0.0))
   , myStribeckVelocity(0.001)
   , myGaussianExponent(2.0)
   , myTau(0.0)
   , myHysteresisFactor(1.0)
   , myBaumgarteStabilizationConstant(double(0.1))
   , myGenerateCollisionSignals(0)
   , myMinimumCollisionVelocityForSignal(double(0.1))
   , mySupportAirDrag




   const CONSTRAINTSOLVERTYPE t = this->constraintSolverType();
      //if (t == CST_IMPULSEBASED)
      //{
         //return new RBDClusterImpulseBased(this);
      //}
      else if (t == CST_PENALTY)
      {
         return new RBDClusterPenalty(this);
      }
      //(ci) use the attached LagrangeDebugObserver
      else if (myLDOPtr)
      {
         return new RBDClusterLagrangeMultipliers(this, myLDOPtr);
      }
   ```
4. RBDScene.h

   ```cpp
    enum CONSTRAINTSOLVERTYPE
      {
         CST_DANTZIG, // <- change
         CST_GS, // <- change
         // CST_LAGRANGEAUTO, 
         //CST_IMPULSEBASED, 
         CST_PENALTY,
         CST_SEQUENTIALIMPULSE
      }; 

   ```

5.RBDClusterLagrangeMultipliers.cpp

```cpp
switch (myScene->constraintSolverType())
      {
      case(RBDScene::CST_DANTZIG):   // <- change
      {
         myLcp = new RBDLcpDantzig(matA.rows(), numberEqualityConstraints);
         break;
      }
      case (RBDScene::CST_GS):      // <- change
      {
         myLcp = new RBDLcpGS(matA.rows(), numberEqualityConstraints, myScene->numberIterations());
         break;
      }
      default:
      {
         if (numberEqualityConstraints <= 0)
            myLcp = new RBDLcpGS(matA.rows(), numberEqualityConstraints, myScene->numberIterations());
         else
            myLcp = new RBDLcpDantzig(matA.rows(), numberEqualityConstraints);
      }
      }

```

6. RBDInverseDynamicsSolverLCP.cpp

```cpp
VSM::VectorN VSLibRBDynamX::RBDInverseDynamicsSolverLCP::solve()
{
   switch (getRBDScene()->constraintSolverType())
   {
   case(RBDScene::CST_DANTZIG) :    // <- change
   {
      myLCP = new RBDLcpDantzig(getDimension(), getNumberEqualityConstraints());
      break;
   }
   case (RBDScene::CST_GS) :    // <- change
   {
      myLCP = new RBDLcpGS(getDimension(), getNumberEqualityConstraints(), getRBDScene()->numberIterations());
      break;
   }
   default:
   {
      if (getNumberEqualityConstraints() <= 0)
         myLCP = new RBDLcpGS(getDimension(), getNumberEqualityConstraints(), getRBDScene()->numberIterations());
      else
         myLCP = new RBDLcpDantzig(getDimension(), getNumberEqualityConstraints());
   }
```

## 关于求解器上的选项问题：












紧急先做一个extension：
